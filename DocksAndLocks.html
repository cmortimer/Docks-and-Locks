<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<style type="text/css">
		body { margin: 0; padding: 0; background: #999;}
		canvas { display: block; margin: 0.5em auto; background: #fff; }
	</style>
	<title>Dock and Lock</title>
</head>
<body>
	<canvas width='640' height='480'>
		Get a real browser!
	</canvas>
	
	
	<script src="Dock.js"></script>
	<script src="Player.js"></script>
	
	<script>
	
	"use strict";
	var app = app || {};
	
	//Keyboard
	app.Keyboard = function(){
		this.left = 37;
		this.up = 38;
		this.right = 39;
		this.down = 40;
	}
	
	app.keydown = [];
	
	window.onload = function(){
	
		app.canvasWIDTH = 1280;
		app.canvasHEIGHT = 720;
		app.dt = 1/60.0;	//placeholder, will be more accurate later
		
		//Keyboard
		app.keyboard = new app.Keyboard();
		window.addEventListener("keydown", function(e){
			app.keydown[e.keyCode] = true;
		});
		
		window.addEventListener("keyup", function(e){
			app.keydown[e.keyCode] = false;
		});
		
		app.docks = [];
		
		app.canvas = document.querySelector('canvas');
		app.canvas.width = app.canvasWIDTH;
		app.canvas.height = app.canvasHEIGHT;
		app.ctx = app.canvas.getContext('2d');
		
		app.docks.push(new app.Dock(100,500,100));
		app.docks.push(new app.Dock(300,500,100));
		app.docks.push(new app.Dock(500,500,100));
		
		console.log(app.docks[0]);
		
		app.docks.update = function(){
		
			var indices = [];

			for(var i = app.docks.length -1 ; i>=0; i--){
				
				//check player collision and junk faking for now
				if(i == 0){
				
					// check to see if colliding platform is at is min height or locked
					if(app.docks[i].platformHeight != app.docks[i].platformMinHeight && !app.docks[i].locked) {
					
						//go though loop and add docks ahead in the list till you hit a lock then break
						for(var j = i +1; j <app.docks.length; j++){
							if(!app.docks[j].locked){
								indices.push(j);
							} else {
								break;
							}
						}
						
						//same as above opposite direction
						for(var j = i -1; j >= 0; j--){
							if(!app.docks[j].locked){
								indices.push(j);
							} else {
								break;
							}
						}
					
						//if can move water the system do so. 
						if(indices.length != 0){
							app.docks[i].setPlatformHeight(-app.docks[i].fallHeight);
							for(var k = indices.length -1; k>=0; k--){
								app.docks[indices[k]].setPlatformHeight(app.docks[i].fallHeight/indices.length);
							}
						}
					}
				}
				app.docks[i].draw(app.ctx);
			}
		}
		
		//Player
		app.player = new app.Player(10, 10, 20, 30);
		console.log(app.player);
		
		app.player.update = function(){
			if(app.keydown[app.keyboard.left]){
				app.player.moveLeft(app.dt);
			}
			if(app.keydown[app.keyboard.right]){
				app.player.moveRight(app.dt);
			}
			if(app.keydown[app.keyboard.up]){
				app.player.jump();
			}
			app.player.moveVertically(100, app.dt);
			app.player.draw(app.ctx);
		}
		
		
		
		
		app.update();
	
	}
	
	app.update =  function(){	
		
		this.ctx.clearRect(0,0,app.canvasWIDTH,app.canvasHEIGHT);
		
		this.ctx.fillStyle = "white";
		
		this.ctx.fillRect(0,0,app.canvasWIDTH,app.canvasHEIGHT);
		
		//app.docks[2].locked = true;
		
		app.docks.update();
		app.player.update();
 		
		requestAnimationFrame(this.update.bind(this));
	}
	
	
	
	
	</script>
	
</body>
</html>